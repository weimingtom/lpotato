<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   
      <title>11.2.&nbsp;函数在脚本中的例子</title>
      <link rel="stylesheet" href="docbook.css" type="text/css">
      <meta name="generator" content="DocBook XSL Stylesheets V1.69.1">
      <meta name="keywords" content="Linux, Scripts, linux, Bash, guide, Guide, Exercises, exercises, bash, scripting, Scripting, awk, sed, variables, functions, loops, conditionals">
      <link rel="start" href="index.html" title="Bash新手指南">
      <link rel="up" href="ch11.html" title="第&nbsp;11&nbsp;章&nbsp;函数">
      <link rel="prev" href="ch11.html" title="第&nbsp;11&nbsp;章&nbsp;函数">
      <link rel="next" href="ch11s03.html" title="11.3.&nbsp;总结">
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">11.2.&nbsp;函数在脚本中的例子</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="ch11.html">上一页</a>&nbsp;
               </td>
               <th width="60%" align="center">第&nbsp;11&nbsp;章&nbsp;函数</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="ch11s03.html">下一页</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div class="sect1" lang="zh-cn">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title" style="clear: both"><a name="sect_11_02"></a>11.2.&nbsp;函数在脚本中的例子
                  </h2>
               </div>
            </div>
         </div>
         <div class="sect2" lang="zh-cn">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a name="sect_11_02_01"></a>11.2.1.&nbsp;循环利用
                     </h3>
                  </div>
               </div>
            </div>
            <p>在你的系统中有大量的脚本使用函数来以结构化的方法处理一系列命令。在某些linux系统上，比如，你可以找到 <code class="filename">/etc/rc.d/init.d/functions</code> 定义文件，source在所有的初始化脚本中。使用这个方法通常只需要编写一次，常见的任务比如检查进程是否运行，开始或者停止一个守护进程等等。如果某些任务还需要一次，代码就可以重新循环使用。从这个 <code class="filename">functions</code> 文件中的checkpid函数：
            </p><pre class="screen">
# Check if $pid (could be plural) are running
checkpid() {
        local i

        for i in $* ; do
                [ -d "/proc/$i" ] &amp;&amp; return 0
        done
        return 1
}
</pre><p>这个函数在相同的脚本中在重用于其他脚本的其他函数中被重用。 <span><strong class="command">守护进程</strong></span> ，比如，多数使用在启动一个服务进程的起始脚本中。
            </p>
         </div>
         <div class="sect2" lang="zh-cn">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a name="sect_11_02_02"></a>11.2.2.&nbsp;设置路径
                     </h3>
                  </div>
               </div>
            </div>
            <p>本节可能可以在你的 <code class="filename">/etc/profile</code> 文件中找到， <span><strong class="command">pathmunge</strong></span> 函数用来定义然后为 <span class="emphasis"><em>root</em></span> 和其他用户设置路径：
            </p><pre class="screen">
pathmunge () {
        if ! echo $PATH | /bin/egrep -q "(^|:)$1($|:)" ; then
           if [ "$2" = "after" ] ; then
              PATH=$PATH:$1
           else
              PATH=$1:$PATH
           fi
        fi
}

# Path manipulation
if [ `id -u` = 0 ]; then
        pathmunge /sbin
        pathmunge /usr/sbin
        pathmunge /usr/local/sbin
fi

pathmunge /usr/X11R6/bin after

unset pathmunge
</pre><p>这个函数把第一个参数设置为路径名。如果路径名不在当前路径中，就把它加入。传给函数的第二个参数定义了路径是加入到当前 <code class="varname">PATH</code> 之前还是之后。
            </p>
            <p>普通用户只把 <code class="filename">/usr/X11R6/bin</code> 加入到他们的路径中，当 <span class="emphasis"><em>root</em></span> 得到了一些包含系统命令的额外目录。使用完毕后，函数就进行unset所以就不存在了。
            </p>
         </div>
         <div class="sect2" lang="zh-cn">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a name="sect_11_02_03"></a>11.2.3.&nbsp;远程备份
                     </h3>
                  </div>
               </div>
            </div>
            <p>以下的例子是用来我用来备份我的文件的。使用SSH密钥来启用远程连接。其中定义了２个函数，<span><strong class="command">buplinux</strong></span> 和 <span><strong class="command">bupbash</strong></span>，每个都产生一个 <code class="filename">.tar</code> 文件，然后压缩送往远程服务器。最后，本地拷贝被清除。
            </p>
            <p>在星期天，只有 <span><strong class="command">bupbash</strong></span> 运行。
            </p><pre class="screen">
#/bin/bash

LOGFILE="/nethome/tille/log/backupscript.log"
echo "Starting backups for `date`" &gt;&gt; "$LOGFILE"

buplinux()
{
DIR="/nethome/tille/xml/db/linux-basics/"
TAR="Linux.tar"
BZIP="$TAR.bz2"
SERVER="rincewind"
RDIR="/var/www/intra/tille/html/training/"

cd "$DIR"
tar cf "$TAR" src/*.xml src/images/*.png src/images/*.eps
echo "Compressing $TAR..." &gt;&gt; "$LOGFILE"
bzip2 "$TAR"
echo "...done." &gt;&gt; "$LOGFILE"
echo "Copying to $SERVER..." &gt;&gt; "$LOGFILE"
scp "$BZIP" "$SERVER:$RDIR" &gt; /dev/null 2&gt;&amp;1
echo "...done." &gt;&gt; "$LOGFILE"
echo -e "Done backing up Linux course:\nSource files, PNG and EPS images.\nRubbish removed." &gt;&gt; "$LOGFILE"
rm "$BZIP"
}

bupbash()
{
DIR="/nethome/tille/xml/db/"
TAR="Bash.tar"
BZIP="$TAR.bz2"
FILES="bash-programming/"
SERVER="rincewind"
RDIR="/var/www/intra/tille/html/training/"

cd "$DIR"
tar cf "$TAR" "$FILES"
echo "Compressing $TAR..." &gt;&gt; "$LOGFILE"
bzip2 "$TAR"
echo "...done." &gt;&gt; "$LOGFILE"
echo "Copying to $SERVER..." &gt;&gt; "$LOGFILE"
scp "$BZIP" "$SERVER:$RDIR" &gt; /dev/null 2&gt;&amp;1
echo "...done." &gt;&gt; "$LOGFILE"

echo -e "Done backing up Bash course:\n$FILES\nRubbish removed." &gt;&gt; "$LOGFILE"
rm "$BZIP"
}

DAY=`date +%w`

if [ "$DAY" -lt "2" ]; then
  echo "It is `date +%A`, only backing up Bash course." &gt;&gt; "$LOGFILE"
  bupbash
else
  buplinux
  bupbash
fi


echo -e "Remote backup `date` SUCCESS\n----------" &gt;&gt; "$LOGFILE"
</pre><p>这个脚本从cron运行，意味着没有用户交互，所以我们对 <span><strong class="command">scp</strong></span> 的标准错误进行重定向到 <code class="filename">/dev/null</code>。
            </p>
            <p>可能引起争论的是所有的分开的步骤可以组合到类似下列的命令：</p>
            <div class="cmdsynopsis">
               <p><code class="command">tar <code class="option">c</code> <code class="filename">dir_to_backup/</code> | bzip2 | ssh <code class="option">server</code> "cat &gt; <code class="filename">backup.tar.bz2</code>"</code> 
               </p>
            </div>
            <p>然而，如果你对能恢复脚本错误的中间的结果感兴趣，这不是你想要的。</p>
            <p>表达式</p>
            <div class="cmdsynopsis">
               <p><code class="command">command &amp;&gt; <code class="filename">file</code></code> 
               </p>
            </div>
            <p>等价于</p>
            <div class="cmdsynopsis">
               <p><code class="command">command &gt; <code class="filename">file</code> 2&gt;&amp;1</code> 
               </p>
            </div>
         </div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="ch11.html">上一页</a>&nbsp;
               </td>
               <td width="20%" align="center"><a accesskey="u" href="ch11.html">上一级</a></td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="ch11s03.html">下一页</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">第&nbsp;11&nbsp;章&nbsp;函数&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td>
               <td width="40%" align="right" valign="top">&nbsp;11.3.&nbsp;总结</td>
            </tr>
         </table>
      </div>
   </body>
</html>